<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="styl.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="script.js" defer></script>
</head>
<body>
    <div class="mikolaj">
        <h2>Testy potwierdzające (regresywne)</h2>
        <p>

            Po zakończeniu procesów testowych oraz wykryciu i naprawie usterek należy jeszcze wykonać retest potwierdzający
            sprawne działanie programu. Tym właśnie jest testowanie regresywne. Polega ono przede wszystkim na ponownym sprawdzeniu oprogramowania 
            pod kątem znalezienia ukrytych wad i błędów. Testy potwierdzające mogą być wykonywane dla wszystkich typów testów i poziomów testowania. 
            Co więcej, ze względu na to, że wymagają powtarzalności, można je łatwo zautomatyzować.
            <br><br>
            Testy regresywne można przeprowadzać zarówno na wszystkich poziomach testów,
            jak i dla wszystkich ich typów (funkcjonalnych, niefunkcjonalnych, strukturalnych).
            <br><br>
            <img src="test.png" width="720px">
        </p>
    </div>
    <div class="zrozumiano-div"><button class="zrozumiano">Zrozumiano!</button></div>
    <div class="testy-funkcjonalne">    
        <h1 class="testy-funkcjonalne-title">Testy funkcjonalne</h1>
        <div class="testy-funkcjonalne-content">
            <div class="testy-funkcjonalne-lewo">
                <img src="testy-publiczne.png" alt="testy publiczne">
            </div>
            <div class="testy-funkcjonalne-prawo">
                Testy funkcjonalne zajmują się zewnętrznym zachowaniem oprogramowania i nazywane nazywane są również czarnoskrzynkowymi. Są odpowiedzialne za testowanie zabezpieczeń programu oraz jego współdziałania z konkretnymi modułami.<br>
                <br>
                Funkcje testowane za pomocą testów funkcjonalnych często opisywane są w specyfikacjach wymagań. Definiują one czynności wykonywane przez oprogramowanie. W prosty sposób wykrywają błędy, jednak nie dostarczają precyzyjnych informacji na temat ich przyczyny wystąpienia.<br>
                <br>
                Tester w tym przypadku nie musi dokładnie znać kodu czy struktury wewnętrznej – testowanie funkcjonalne zwraca mu po prostu dane wyjściowe po wprowadzeniu danych wejściowych. Nie skupia się jednak na tym, w jaki sposób te informacje zostają generowane.<br>
                <br>
                Do testów funkcjonalnych zaliczyć możemy między innymi testy eksploracyjne. Opierają się one na doświadczeniu i intuicji testera. Wykorzystuje się je w momencie, kiedy nie mamy dostępu do pełnej dokumentacji, a inny rodzaj testowania jest awykonalny. W przypadku prostych aplikacji testy eksploracyjne są świetnym rozwiązaniem, ponieważ nie są skomplikowane i czasochłonne.<br>
                <br>
                Co ważne, testy funkcjonalne mogą być wykonywane na każdym poziomie testowania.<br>
            </div>
        </div>
    </div>
    <div class="zrozumiano-div"><button class="zrozumiano">Zrozumiano!</button></div>
    <div class="testy-strukturalne">
        <h2>Testy Strukturalne</h2>
        <div class="strukturalne-opis">
            Testy te nazywane są białoskrzynkowymi. 
            Podobnie jak w przypadku testów niefunkcjonalnych i czarnoskrzynkowych, 
            testy strukturalne mogą być przeprowadzane na każdym poziomie testowania.
        </div>
        <div class="strukturalne-opis">
            Testy białoskrzynkowe warto przeprowadzić tuż po testowaniu opartym na specyfikacji,
            aby zwiększyć dokładność pomiarów. 
            Wykorzystywanie testów strukturalnych umożliwia pomiar precyzji obszaru testowanego 
            dzięki oszacowaniu stopnia pokrycia wybranego typu struktury przez inne typy testów.
            Jeśli pomiar wynosi mniej niż 100%, 
            można opracować nowe typy testów, 
            które zwiększą poziom pokrycia struktury.
        </div>
        <div class="strukturalne-zalety">
            <h3>Zalety</h3>
            <ul>
                <li>Dokładność wynikająca z bezpośredniego przełożenia na strukturę kodu źródłowego.</li>
                <li>Łatwość optymalizacji owego kodu, dzięki jasnej identyfikacji wąskich gardeł.</li>
                <li>Łatwość zautomatyzowania.</li>
                <li>Inżynieryjna klarowność procedury: jej postępu i zakończenia.</li>
            </ul>
        </div>
        <div class="strukturalne-wady">
            <h3>Wady</h3>
            <ul>
                <li>Zespół testowy musi posiadać głęboką, profesjonalną wiedzę o strukturze kodu źródłowego.</li>
                <li>W niektórych przypadkach niemożliwe jest przetestowanie każdego potencjalnego stanu programu.</li>
                <li>Testy koncentrują się na istniejących aspektach kodu; problemy braków funkcjonalności mogą nie zostać wykryte.</li>
            </ul>
        </div>
    </div>
    <div class="zrozumiano-div"><button class="zrozumiano">Zrozumiano!</button></div>
</body>
</html>